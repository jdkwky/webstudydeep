<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 第一天作业公布：
🎁 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。
该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。
如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1。
🎁__proto__ 和 prototype 之前有什么关系？
🎁 .call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？
（请详细查看每日时间节奏图，按时打卡和完成作业，老师会给大家准时讲解👏 ） -->


<script>

    const list  = [3,1,3,2,5,4,5];
    function rank(k, nums){
        const newNums = Array.from(new Set(nums));
        const rankNums = newNums.sort((val1,val2) => val2 - val1);
        return rankNums[k -1];
    }

    console.log(rank(5,list));

    // array

    const likeArray = {
        0: 1,
        length: 2
    };

    // 数组中的每个元素都会执行该函数
    const result = Array.from(likeArray,(x,i) => i);
    console.log(result, 'result');

    class Parent{}
    class Child extends Parent {}

    var child = new Child();
    console.log(child instanceof Parent, 'parent') 

    console.log([{ name: 'test', quantity :3 }].find(val => val.name =='test'));

    var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];
    function flatDeep(arr, d=1){
        return d > 0 ? arr.reduce((acc , next) => Array.isArray(next) ? acc.concat(flatDeep(next, d-1)) : acc.concat(next),[]) : arr.slice()
    }

    const reFlat = flatDeep(arr1, 1);
    console.log(reFlat, 'result reFlat');


    // 纯递归的形势
    function flatDeep2(arr, d){
        if(d > 0){
            let result = [];
            for(let i = 0 ,len = arr.length ; i < len ; i++){
                if(!Array.isArray(arr[i])){
                    result.push(arr[i]);
                }else{
                    result = result.concat(flatDeep2(arr[i],d-1));
                }
            }
            return result;
        }else{
            return arr.slice();
        }
    }

    const reFlat1 = flatDeep2(arr1, 1);

    console.log(reFlat1, 'result reFlat');


    // function rank(k, nums){
    //     const result = {};
    //     let index = 0;
    //     for(let i =0, len = nums.length; i < len; i++){
    //         for( let j = i+1; j < len; j++ ){
    //             if(nums[i] < nums[j]){
    //                 const temp = nums[i];
    //                 nums[i] = nums[j];
    //                 nums[j] = temp;
    //             }
    //         }
    //         if(result[nums[i]] == null) {
    //             result[nums[i]] = index;
    //             index++
                
    //         }
    //         if(result[nums[i]] == k-1){
    //             return nums[i];
    //         }
            
    //     }
    // }
    // // __proto__ 是创建对象的时候指向对象原型链的

    // // call  apply bind 
    // //  共同点： 改变this指向
    // //  区别点： 
    //  //   call 传入的参数是普通传参方式，
    //  //   apply传入的参数是数组，
    //  //   bind只接收一个参数用于改变this指向并返回一个函数
    // Function.prototype._bind = function(context){
    //     const fn = this;
    //     if(typeof fn !=='function'){
    //         throw('fn is a function')
    //     }
    //     return function(...args){
    //         fn.apply(context, args)
    //     }
    // }

</script>
</body>
</html>